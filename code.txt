import argparse
from antlr4 import *
from antlr4.TokenStreamRewriter import TokenStreamRewriter

# 假设已通过ANTLR生成Kotlin语法解析器
# 请确保以下导入路径与实际生成的Kotlin语法解析器匹配
from KotlinLexer import KotlinLexer
from KotlinParser import KotlinParser
from KotlinParserListener import KotlinParserListener

class FunctionModifierListener(KotlinParserListener):
    def __init__(self, function_name, rewriter, new_code, insert_at_start):
        self.function_name = function_name
        self.rewriter = rewriter
        self.new_code = new_code
        self.insert_at_start = insert_at_start
        self.found = False

    def enterFunctionDeclaration(self, ctx: KotlinParser.FunctionDeclarationContext):
        # 提取函数标识符
        identifier = ctx.simpleIdentifier().getText()
        if identifier == self.function_name:
            # 获取函数体块结构
            function_body = ctx.functionBody()
            if function_body and function_body.block():
                block = function_body.block()
                lbrace = block.LBRACE().symbol
                rbrace = block.RBRACE().symbol

                # 根据插入位置操作Token流
                if self.insert_at_start:
                    self.rewriter.insertAfter(lbrace, f'\n{self.new_code}')
                else:
                    self.rewriter.insertBefore(rbrace, f'\n{self.new_code}')
                
                self.found = True

def modify_kotlin_function(
    file_path: str,
    function_name: str,
    new_code: str,
    insert_at_start: bool = True
) -> None:
    """
    修改指定Kotlin文件中的函数代码
    
    :param file_path: Kotlin文件路径
    :param function_name: 目标函数名
    :param new_code: 要插入的新代码（需包含正确缩进）
    :param insert_at_start: True=在函数开头插入，False=在结尾插入
    """
    # 读取文件内容
    input_stream = FileStream(file_path, encoding='utf-8')
    
    # 初始化词法分析和语法分析
    lexer = KotlinLexer(input_stream)
    token_stream = CommonTokenStream(lexer)
    parser = KotlinParser(token_stream)
    parse_tree = parser.kotlinFile()
    
    # 创建代码重写工具
    rewriter = TokenStreamRewriter(token_stream)
    
    # 创建自定义监听器
    listener = FunctionModifierListener(
        function_name=function_name,
        rewriter=rewriter,
        new_code=new_code,
        insert_at_start=insert_at_start
    )
    
    # 遍历语法树
    walker = ParseTreeWalker()
    walker.walk(listener, parse_tree)
    
    if not listener.found:
        raise ValueError(f"Function '{function_name}' not found or has no block body")
    
    # 应用修改并写回文件
    modified_code = rewriter.getText('default', 0, token_stream.size)
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(modified_code)

if __name__ == "__main__":
    # 命令行参数解析
    parser = argparse.ArgumentParser()
    parser.add_argument("file", help="Kotlin文件路径")
    parser.add_argument("function", help="目标函数名")
    parser.add_argument("code", help="要插入的代码内容")
    parser.add_argument("--position", choices=["start", "end"], default="start",
                        help="插入位置：start（开头）或 end（结尾）")
    
    args = parser.parse_args()
    
    # 执行修改操作
    modify_kotlin_function(
        file_path=args.file,
        function_name=args.function,
        new_code=args.code,
        insert_at_start=(args.position == "start")
    )
    print(f"代码已成功插入到函数 {args.function} 的{args.position}位置")
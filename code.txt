from antlr4 import FileStream, CommonTokenStream
from KotlinLexer import KotlinLexer
from KotlinParser import KotlinParser
from KotlinParserVisitor import KotlinParserVisitor

class FunctionVisitor(KotlinParserVisitor):
    def __init__(self, target_function_name):
        self.target_name = target_function_name
        self.result = None

    def visitFunctionDeclaration(self, ctx: KotlinParser.FunctionDeclarationContext):
        # 提取函数名并比较
        function_name = ctx.simpleIdentifier().getText()
        if function_name == self.target_name:
            # 检查是否存在包含花括号的函数体
            function_body = ctx.functionBody()
            if function_body:
                block = function_body.block()
                if block:
                    # 获取花括号的行号
                    start_line = block.start.line
                    end_line = block.stop.line
                    if self.result is None:
                        self.result = (start_line, end_line)
        # 递归访问子节点以确保遍历整个树
        return self.visitChildren(ctx)

def get_function_brace_lines(file_path: str, function_name: str) -> tuple:
    # 读取文件并解析
    input_stream = FileStream(file_path, encoding='utf-8')
    lexer = KotlinLexer(input_stream)
    token_stream = CommonTokenStream(lexer)
    parser = KotlinParser(token_stream)
    tree = parser.kotlinFile()  # 解析Kotlin文件

    visitor = FunctionVisitor(function_name)
    visitor.visit(tree)

    if visitor.result is not None:
        return visitor.result
    else:
        raise ValueError(
            f"函数 '{function_name}' 未找到或没有包含花括号的函数体。"
        )

# 示例用法
if __name__ == "__main__":
    try:
        # 替换为实际文件路径和函数名
        lines = get_function_brace_lines("demo.kt", "exampleFunction")
        print(f"起始行: {lines[0]}, 结束行: {lines[1]}")
    except ValueError as e:
        print(e)